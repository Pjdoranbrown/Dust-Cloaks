<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dust Cloaks</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer" class="hidden">
        <div id="xp-bar-container"><div id="xp-bar"></div></div>
        
        <div id="top-hud" class="hud-panel">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <span style="font-size:10px; color:#ddd;">CONDITION</span>
                <div id="hp-container"><div id="hp-bar"></div></div>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center;">
                <span style="font-size:10px; color:#ddd;">LUCK (PRESS Q)</span>
                <div id="luck-container">
                    <div id="luck-bar"></div>
                    <div id="luck-text">0 / 10</div>
                </div>
            </div>
            <div>
                <span style="font-size:10px; color:#ddd;">TIME</span><br>
                <span id="timer" style="font-size:20px;">00:00</span>
            </div>
            <div>
                <span style="font-size:10px; color:#ddd;">SQUAD</span><br>
                <span id="squad-count" style="font-size:20px;">1/6</span>
            </div>
            <div>
                <span style="font-size:10px; color:#ddd;">LEVEL</span><br>
                <span id="level-display" style="font-size:20px;">1</span>
            </div>
            <div>
                <span style="font-size:10px; color:#ddd;">GOLD</span><br>
                <span id="gold-hud" style="font-size:20px; color: gold;">0</span>
            </div>
        </div>

        <div id="formation-indicator" class="hud-panel">
            TACTIC: <span id="tactic-name" style="color:#d4af37">WEDGE</span> <span style="font-size:12px; color:#aaa;">[SPACE]</span>
        </div>

        <div id="tutorial">
            WASD: Move<br>
            SPACE: Toggle Formation (Requires Lvl 3 Soldier)<br>
            Q: Burn Luck (Ultimate)
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen menu-screen">
        <h1>Dust Cloaks</h1>
        <div id="gold-display">Gold: 0</div>
        
        <div style="margin-top: 30px; display: flex; gap: 20px;">
            <button class="btn" onclick="startCreation()">RECRUIT SQUAD LEADER</button>
        </div>
        
        <div style="margin-top: 15px;">
            <button class="btn btn-small" onclick="openRoster()">ROSTER</button>
            <button class="btn btn-small" onclick="openCamp()">CAMP UPGRADES</button>
            <button class="btn btn-small" onclick="openManual()">PLAYER'S MANUAL</button>
        </div>

        <!-- VISUALS CONTAINER -->
        <div id="camp-visuals"></div>
    </div>
    
    <!-- Character Creation Screen -->
    <div id="char-creation-screen" class="screen menu-screen hidden">
        <h1 id="creation-title">Select Race</h1>
        <div id="creation-steps">
            <div id="step-race" class="creation-step active"><div id="race-selection-grid"></div></div>
            <div id="step-class" class="creation-step"><div id="char-selection-grid"></div></div>
            <div id="step-name" class="creation-step">
                <p style="font-size:24px; font-weight:bold;">Identity Confirmation</p>
                <div id="name-input-container">
                    <input type="text" id="char-name-input" placeholder="Enter Name">
                    <button class="btn btn-small" onclick="randomizeName()">Randomize</button>
                </div>
                <button class="btn" onclick="finalizeCreation()">SIGN CONTRACT</button>
            </div>
        </div>
        <button class="btn btn-small" style="margin-top: 20px;" onclick="closeCreation()">CANCEL</button>
    </div>

    <!-- Roster Screen -->
    <div id="roster-screen" class="screen menu-screen hidden">
        <h1>Active Roster</h1>
        <button class="btn btn-small" onclick="closeRoster()">BACK</button>
        <div id="roster-grid"></div>
    </div>
    
    <!-- Camp Screen -->
    <div id="camp-screen" class="screen menu-screen hidden">
        <h1>Camp Upgrades</h1>
        <div id="camp-gold" style="color:#8b0000; font-size:24px; margin-bottom:10px; font-weight:bold;">Gold: 0</div>
        <button class="btn btn-small" onclick="closeCamp()">BACK TO CONTRACTS</button>
        <div id="camp-grid"></div>
    </div>

    <!-- Manual Screen -->
    <div id="manual-screen" class="screen menu-screen hidden">
        <h1>Player's Manual</h1>
        <button class="btn btn-small" onclick="closeManual()">BACK TO MENU</button>
        <div id="manual-content"></div>
    </div>

    <!-- Level Up Screen (In-Game Overlay) -->
    <div id="levelup-screen" class="screen overlay-screen hidden">
        <h1 style="font-size: 32px;">RECRUITMENT</h1>
        <p style="color:#aaa;">Upgrade Squad or Recruit New</p>
        <div id="upgrade-grid"></div>
    </div>

    <!-- Game Over Screen (In-Game Overlay) -->
    <div id="gameover-screen" class="screen overlay-screen hidden">
        <h1 style="color: #b22222;">SQUAD BROKEN</h1>
        <p id="death-stats" style="color:#aaa;">You survived for 00:00</p>
        <button id="resurrect-btn" class="btn" style="border-color: #4169e1; color: #4169e1;" onclick="resurrectLeader()">RESURRECT LEADER (10g)</button>
        <button class="btn" onclick="location.reload()">RETURN TO GUILD</button>
    </div>

    <!-- Win Screen (In-Game Overlay) -->
    <div id="win-screen" class="screen overlay-screen hidden">
        <h1 style="color: #4169e1;">CONTRACT COMPLETE</h1>
        <p style="color:#aaa;">The area is secure.</p>
        <button class="btn" onclick="location.reload()">COLLECT PAYMENT</button>
    </div>


<script src="js/config.js"></script>
<script src="js/state.js"></script>
<script>

// ==========================================
// 3. PERSISTENCE & UTILS
// ==========================================

function loadGame() {
    const data = localStorage.getItem(SAVE_KEY);
    if (data) {
        try {
            const parsed = JSON.parse(data);
            META.gold = parsed.gold || 0;
            META.upgrades = parsed.upgrades || {};
            META.roster = parsed.roster || [];
        } catch(e) { console.error("Save Corrupt"); }
    }
    updateGoldUI();
    renderCampVisuals(); // Show visuals on load
}

function saveGame() {
    localStorage.setItem(SAVE_KEY, JSON.stringify(META));
    updateGoldUI();
}

function updateGoldUI() {
    const displays = ['gold-display', 'camp-gold', 'gold-hud'];
    displays.forEach(id => {
        const el = document.getElementById(id);
        if(el) el.innerText = (id === 'gold-hud' ? '' : 'Gold: ') + META.gold;
    });
}

function getRandomName(raceKey) {
    const list = NAMES[raceKey] || NAMES.HUMAN;
    return list[Math.floor(Math.random() * list.length)];
}

function addFloatingText(x, y, text, color) {
    floatingTexts.push({ x, y, text, color, life: 30 });
}

function checkCollision(c1, c2) {
    const dx = c1.x - c2.x;
    const dy = c1.y - c2.y;
    return Math.hypot(dx, dy) < c1.radius + c2.radius;
}

function getNearestEnemy(x, y, range) {
    let nearest = null;
    let minDst = range;
    for (const e of enemies) {
        const dst = Math.hypot(e.x - x, e.y - y);
        if (dst < minDst) { minDst = dst; nearest = e; }
    }
    return nearest;
}

function loadAssets() {
    const sources = {
        SOLDIER: 'tile_0087.png', MAGE: 'tile_0084.png', CLERIC: 'tile_0098.png',
        SCOUNDREL: 'tile_0100.png', WITCH: 'tile_0111.png', FOLK_HERO: 'tile_0112.png',
        BACKGROUND: 'battlfield_tileset.png',
        RAT: 'tile_0123.png', BAT: 'tile_0120.png', OGRE: 'tile_0109.png', CRAB: 'tile_0110.png',
        // Camp Buildings
        TENT: 'tent.png', STABLE: 'stable.png', HOUSE: 'house.png',
        BROTHEL: 'houseChimney.png', ALCHEMY: 'runis.png', MAGE_TOWER: 'towerTall.png',
        CHAPEL: 'church.png', CHURCH: 'churchLarge.png', PENS: 'dock.png', RANGER: 'houseSmall.png',
        // New Buildings
        TOWER_WATCH: 'towerWatch.png', FENCE: 'fence.png', WALL: 'wall.png', 
        PINES: 'treePinesSmall.png', FIRE: 'campfire.png'
    };
    for(let key in sources) {
        const img = new Image();
        img.src = sources[key];
        ASSETS[key] = img;
    }
}

// ==========================================
// 4. GAME ENTITIES (CLASSES)
// ==========================================

class Entity {
    constructor(x, y, radius, color) {
        this.x = x; this.y = y; this.radius = radius; this.color = color;
        this.markedForDeletion = false;
    }
    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
    }
}

class SquadMate extends Entity {
    constructor(type, index, raceKey = 'HUMAN', name = 'Grunt') {
        super(0, 0, 10, CLASS_DEFS[type].color);
        this.type = type;
        this.race = raceKey;
        this.name = name;
        this.stats = { ...CLASS_DEFS[type] };
        this.cooldownTimer = 0;
        this.specialTimer = 0; 
        this.index = index; 
        this.level = META.upgrades['guildhall'] ? 2 : 1; 
        this.applyUpgrades();
        this.applyRaceStats();
    }

    applyRaceStats() {
        const r = RACES[this.race];
        if (r) {
            if (r.dmgMult) this.stats.damage = Math.ceil(this.stats.damage * r.dmgMult);
            if (r.dmgFlat) this.stats.damage += r.dmgFlat;
            if (r.cooldownMult) this.stats.cooldown = Math.ceil(this.stats.cooldown * r.cooldownMult);
        }
    }

    applyUpgrades() {
        if (META.upgrades['blacksmith']) this.stats.damage = Math.ceil(this.stats.damage * 1.1);
        if (META.upgrades['command']) this.stats.cooldown = Math.ceil(this.stats.cooldown * 0.95);
        let dmgMult = 1.0;
        if (this.type === 'WITCH' && META.upgrades['alchemy']) dmgMult = 1.25;
        if (this.type === 'MAGE' && META.upgrades['magetower']) dmgMult = 1.25;
        if (this.type === 'FOLK_HERO' && META.upgrades['ranger']) dmgMult = 1.25;
        if (this.type === 'CLERIC' && META.upgrades['chapel']) dmgMult = 1.25;
        if (this.type === 'SCOUNDREL' && META.upgrades['pens']) dmgMult = 1.25;
        if (this.type === 'SOLDIER' && META.upgrades['armory']) dmgMult = 1.25;
        this.stats.damage = Math.ceil(this.stats.damage * dmgMult);
    }

    upgrade() {
        this.level++;
        if (this.type === 'CLERIC') {
            this.stats.damage = Math.floor(this.stats.damage * 1.5);
            this.stats.range += 15; 
        } else if (this.type === 'FOLK_HERO') {
            this.stats.damage += 5;
            this.stats.cooldown = Math.max(10, Math.floor(this.stats.cooldown * 0.8)); 
        } else if (this.type === 'MAGE') {
            this.stats.damage += 5;
        } else if (this.type === 'SCOUNDREL') {
            this.stats.damage += 10;
            this.stats.cooldown = Math.max(10, Math.floor(this.stats.cooldown * 0.9));
        } else if (this.type === 'SOLDIER') {
            this.stats.damage += 5;
            this.stats.cooldown = Math.max(10, Math.floor(this.stats.cooldown * 0.9));
        }
        checkSquadSynergies();
        addFloatingText(player.x, player.y, `LVL UP!`, "#4169e1");
    }

    update(leaderX, leaderY, leaderAngle, formation) {
        let targetX, targetY;
        const spacing = 25;
        let commanderX = leaderX;
        let commanderY = leaderY;
        let commanderAngle = leaderAngle;

        if (this.index >= 7) {
            const leader2 = squad[6];
            commanderX = leader2.x;
            commanderY = leader2.y;
        } 
        
        if (this.index === 0) {
            this.x = leaderX; this.y = leaderY;
        } else if (this.index === 6) {
            const trailDist = 80;
            targetX = leaderX - Math.cos(leaderAngle) * trailDist;
            targetY = leaderY - Math.sin(leaderAngle) * trailDist;
            this.x += (targetX - this.x) * (CONFIG.SQUAD_FOLLOW_SPEED * 0.8);
            this.y += (targetY - this.y) * (CONFIG.SQUAD_FOLLOW_SPEED * 0.8);
        } else {
            const localIndex = this.index >= 7 ? this.index - 6 : this.index; 
            if (formation === 'WEDGE') {
                const side = localIndex % 2 === 0 ? 1 : -1;
                const row = Math.ceil(localIndex / 2);
                const offsetX = -row * spacing * 1.5; 
                const offsetY = side * row * spacing; 
                const rotX = offsetX * Math.cos(commanderAngle) - offsetY * Math.sin(commanderAngle);
                const rotY = offsetX * Math.sin(commanderAngle) + offsetY * Math.cos(commanderAngle);
                targetX = commanderX + rotX;
                targetY = commanderY + rotY;
            } else { 
                const totalMates = 5; 
                const angleStep = (Math.PI * 2) / totalMates;
                const angle = (localIndex - 1) * angleStep;
                targetX = commanderX + Math.cos(angle) * spacing;
                targetY = commanderY + Math.sin(angle) * spacing;
            }
            this.x += (targetX - this.x) * CONFIG.SQUAD_FOLLOW_SPEED;
            this.y += (targetY - this.y) * CONFIG.SQUAD_FOLLOW_SPEED;
        }

        if (this.level >= 3) this.handleSpecials();
        if (this.cooldownTimer > 0) this.cooldownTimer--;
        else this.performAttack(leaderAngle);
    }

    handleSpecials() {
        if (this.type === 'CLERIC') {
            this.specialTimer++;
            if (this.specialTimer >= 600) {
                GAME.hp = Math.min(GAME.hp + 15, GAME.maxHp);
                addFloatingText(this.x, this.y - 20, "+SQUAD HEAL", "#gold");
                this.specialTimer = 0;
            }
        } else if (this.type === 'MAGE') {
            this.specialTimer++;
            if (this.specialTimer >= 240) { 
                const fx = this.x + (Math.random() * 300 - 150);
                const fy = this.y + (Math.random() * 300 - 150);
                projectiles.push(new FireballZone(fx, fy));
                this.specialTimer = 0;
            }
        }
    }

    draw() {
        if (this.index === 0) return; 
        const img = ASSETS[this.stats.imgKey];
        if (img && img.complete && img.naturalWidth !== 0) {
            const size = this.radius * 3.0; 
            ctx.drawImage(img, this.x - size/2, this.y - size/2, size, size);
            if (this.index === 6) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#D4AF37";
                ctx.stroke();
            }
        } else {
            super.draw();
        }
    }

    performAttack(angle) {
        const enemy = getNearestEnemy(this.x, this.y, this.stats.range);
        if (this.type === 'SOLDIER' && enemy) {
            projectiles.push(new MeleeSwipe(this.x, this.y, enemy.x, enemy.y, this.stats.damage));
            this.cooldownTimer = this.stats.cooldown;
        } else if (this.type === 'MAGE' && enemy) {
            projectiles.push(new MagicMissile(this.x, this.y, enemy, this.stats.damage));
            this.cooldownTimer = this.stats.cooldown;
        } else if (this.type === 'SCOUNDREL') {
            if (enemy) {
                projectiles.push(new DaggerMelee(this.x, this.y, enemy.x, enemy.y, this.stats.damage));
                this.cooldownTimer = this.stats.cooldown;
            }
            if (this.level >= 3 && Math.random() > 0.7) projectiles.push(new Trap(this.x, this.y, this.stats.damage));
        } else if (this.type === 'CLERIC' && getNearestEnemy(this.x, this.y, this.stats.range)) {
            projectiles.push(new Shockwave(this.x, this.y, this.stats.range, this.stats.damage));
            this.cooldownTimer = this.stats.cooldown;
        } else if (this.type === 'WITCH' && enemy) {
            projectiles.push(new PoisonBolt(this.x, this.y, enemy, this.stats.damage, this.level >= 3));
            this.cooldownTimer = this.stats.cooldown;
        } else if (this.type === 'FOLK_HERO') {
            projectiles.push(new StraightShot(this.x, this.y, angle, this.stats.damage));
            this.cooldownTimer = this.stats.cooldown;
        }
    }
}

class Enemy extends Entity {
    constructor() {
        const time = GAME.time;
        let typeKey = 'RAT';
        if (time < 30) typeKey = 'RAT';
        else if (time < 60) typeKey = Math.random() > 0.5 ? 'BAT' : 'RAT';
        else if (time < 90) typeKey = Math.random() > 0.2 ? 'BAT' : 'RAT';
        else {
            const rand = Math.random();
            if (rand < 0.1) typeKey = 'RAT'; else if (rand < 0.55) typeKey = 'OGRE'; else typeKey = 'CRAB';
        }
        const stats = ENEMY_DEFS[typeKey];
        const side = Math.floor(Math.random() * 4);
        let x, y;
        const pad = 50;
        if (side === 0) { x = Math.random() * GAME.width; y = -pad; }
        else if (side === 1) { x = GAME.width + pad; y = Math.random() * GAME.height; }
        else if (side === 2) { x = Math.random() * GAME.width; y = GAME.height + pad; }
        else { x = -pad; y = Math.random() * GAME.height; }

        super(x, y, 12, stats.color);
        this.typeStats = stats;
        this.hp = stats.hp + (GAME.level * 3);
        this.maxSpeed = stats.speed * (0.9 + Math.random() * 0.2);
        this.damage = stats.damage;
        this.xp = stats.xp;
        if (typeKey === 'OGRE') this.radius = 20;
        this.poisoned = false; this.poisonDmg = 0; this.fearTimer = 0; this.slowTimer = 0;
    }

    update() {
        if (this.poisoned && GAME.frames % 60 === 0) takeEnemyDamage(this, this.poisonDmg, false);
        if (this.slowTimer > 0) this.slowTimer--;
        if (this.fearTimer > 0) this.fearTimer--;

        let dx = player.x - this.x;
        let dy = player.y - this.y;
        if (this.fearTimer > 0) { const temp = dx; dx = -dy; dy = temp; }

        const dist = Math.hypot(dx, dy);
        let currentSpeed = this.maxSpeed;
        if (this.slowTimer > 0) currentSpeed *= 0.5;

        if (dist > 0) {
            this.x += (dx / dist) * currentSpeed;
            this.y += (dy / dist) * currentSpeed;
        }

        if (checkCollision(this, player)) {
            takePlayerDamage(this.damage);
            this.markedForDeletion = true; 
        }
    }

    draw() {
        const img = ASSETS[this.typeStats.imgKey];
        if (img && img.complete && img.naturalWidth !== 0) {
            const size = this.radius * this.typeStats.scale; 
            ctx.save();
            if (this.poisoned) ctx.filter = 'sepia(1) hue-rotate(50deg)';
            if (this.fearTimer > 0) ctx.filter = 'invert(1)';
            ctx.drawImage(img, this.x - size/2, this.y - size/2, size, size);
            ctx.restore();
        } else {
            super.draw();
        }
    }
}

class XPOrb extends Entity {
    constructor(x, y, val) { super(x, y, 4, '#4169e1'); this.value = val; }
    update() {
        let pickupRange = CONFIG.BASE_PICKUP_RADIUS;
        if (META.upgrades['herbalist']) pickupRange *= 1.2;
        if (squad.some(m => m.type === 'FOLK_HERO' && m.level >= 3)) pickupRange *= 2.5;

        const dist = Math.hypot(player.x - this.x, player.y - this.y);
        if (dist < pickupRange) { 
            this.x += (player.x - this.x) * 0.15;
            this.y += (player.y - this.y) * 0.15;
        }
        if (dist < player.radius + 10) {
            gainXP(this.value);
            this.markedForDeletion = true;
        }
    }
    draw() {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color; ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
    }
}

class GoldOrb extends Entity {
    constructor(x, y) { super(x, y, 5, '#ffd700'); }
    update() {
        let pickupRange = CONFIG.BASE_PICKUP_RADIUS;
        const dist = Math.hypot(player.x - this.x, player.y - this.y);
        if (dist < pickupRange) { 
            this.x += (player.x - this.x) * 0.15;
            this.y += (player.y - this.y) * 0.15;
        }
        if (dist < player.radius + 10) {
            currentRunStats.gold += 1;
            META.gold += 1;
            saveGame();
            addFloatingText(this.x, this.y, "+1g", "gold");
            this.markedForDeletion = true;
        }
    }
    draw() {
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "gold"; ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
    }
}

// ==========================================
// 5. PROJECTILES
// ==========================================

class Projectile extends Entity {
    constructor(x, y, r, color, damage, duration) {
        super(x, y, r, color);
        this.damage = damage;
        this.duration = META.upgrades['engineering'] ? Math.floor(duration * 1.2) : duration;
    }
    update() {
        this.duration--;
        if (this.duration <= 0) this.markedForDeletion = true;
    }
}

class MagicMissile extends Projectile {
    constructor(x, y, target, damage) {
        super(x, y, 5, '#87CEEB', damage, 60);
        this.target = target;
        this.speed = META.upgrades['carpentry'] ? 8.4 : 7;
    }
    update() {
        super.update();
        if (this.target && !this.target.markedForDeletion) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.hypot(dx, dy);
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            if (dist < 10) { takeEnemyDamage(this.target, this.damage); this.markedForDeletion = true; }
        } else { this.markedForDeletion = true; }
    }
}

class FireballZone extends Projectile {
    constructor(x, y) { super(x, y, 60, 'rgba(255, 69, 0, 0.4)', 5, 240); }
    update() {
        super.update();
        if (this.duration % 20 === 0) {
            enemies.forEach(e => { if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius) takeEnemyDamage(e, this.damage, false); });
        }
    }
}

class MeleeSwipe extends Projectile {
    constructor(x, y, tx, ty, damage) {
        super(x, y, 35, 'rgba(200,200,200,0.5)', damage, 8);
        enemies.forEach(e => { if (Math.hypot(e.x - x, e.y - y) < 45) takeEnemyDamage(e, damage, true); });
    }
}

class DaggerMelee extends Projectile {
    constructor(x, y, tx, ty, damage) {
        super(x, y, 10, '#fff', damage, 5);
        const angle = Math.atan2(ty - y, tx - x);
        const hx = x + Math.cos(angle) * 20;
        const hy = y + Math.sin(angle) * 20;
        enemies.forEach(e => { if (Math.hypot(e.x - hx, e.y - hy) < 20) takeEnemyDamage(e, damage); });
    }
}

class Trap extends Projectile {
    constructor(x, y, damage) { super(x, y, 15, '#8B4513', damage, 600); this.active = true; }
    update() {
        if (!this.active) { this.markedForDeletion = true; return; }
        this.duration--;
        if (this.duration <= 0) this.markedForDeletion = true;
        enemies.forEach(e => {
            if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius + e.radius) {
                takeEnemyDamage(e, this.damage);
                e.slowTimer = 180;
                this.active = false;
                addFloatingText(this.x, this.y, "SNAP!", "red");
            }
        });
    }
}

class Shockwave extends Projectile {
    constructor(x, y, range, damage) {
        super(x, y, range, 'rgba(255, 215, 0, 0.3)', damage, 15);
        enemies.forEach(e => {
             if (Math.hypot(e.x - x, e.y - y) < range) {
                 takeEnemyDamage(e, damage, true);
                 const angle = Math.atan2(e.y - y, e.x - x);
                 e.x += Math.cos(angle) * 30; e.y += Math.sin(angle) * 30;
             }
        });
    }
}

class PoisonBolt extends Projectile {
    constructor(x, y, target, damage, causesFear) {
        super(x, y, 6, '#800080', damage, 60);
        this.target = target; this.causesFear = causesFear;
        this.speed = META.upgrades['carpentry'] ? 7.2 : 6;
    }
    update() {
        super.update();
        if (this.target && !this.target.markedForDeletion) {
             const dx = this.target.x - this.x; const dy = this.target.y - this.y;
             const dist = Math.hypot(dx, dy);
             this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed;
             if (dist < 10) {
                 takeEnemyDamage(this.target, this.damage);
                 this.target.poisoned = true; this.target.poisonDmg = 2;
                 if (this.causesFear) this.target.fearTimer = 120;
                 this.markedForDeletion = true;
             }
        } else { this.markedForDeletion = true; }
    }
}

class StraightShot extends Projectile {
    constructor(x, y, angle, damage) {
        super(x, y, 5, '#228B22', damage, 60);
        let speed = META.upgrades['carpentry'] ? 12 : 10;
        this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
    }
    update() {
        super.update();
        this.x += this.vx; this.y += this.vy;
        enemies.forEach(e => {
            if (checkCollision(this, e)) { takeEnemyDamage(e, this.damage); this.markedForDeletion = true; }
        });
    }
}

// ==========================================
// 6. UI & MENU SYSTEMS
// ==========================================

function startCreation() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('char-creation-screen').classList.remove('hidden');
    creationData = { race: null, classKey: null, name: "" };
    showCreationStep('race');
    renderRaceSelection();
}

function showCreationStep(step) {
    document.querySelectorAll('.creation-step').forEach(el => el.classList.remove('active'));
    document.getElementById(`step-${step}`).classList.add('active');
    const titles = { 'race': "Select Race", 'class': "Select Speciality", 'name': "Enter Name" };
    document.getElementById('creation-title').innerText = titles[step];
}

function renderRaceSelection() {
    const grid = document.getElementById('race-selection-grid');
    grid.innerHTML = '';
    for (const key in RACES) {
        const race = RACES[key];
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `<div class="card-title">${race.name}</div><div class="card-desc">${race.desc}</div><div class="card-desc" style="color:#8b0000; margin-top:5px; font-weight:bold;">${race.statsText}</div>`;
        card.onclick = () => { creationData.race = key; showCreationStep('class'); renderClassSelection(); };
        grid.appendChild(card);
    }
}

function renderClassSelection() {
    const grid = document.getElementById('char-selection-grid');
    grid.innerHTML = '';
    for (const key in CLASS_DEFS) {
        const def = CLASS_DEFS[key];
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `<img src="${ASSETS[def.imgKey]?.src}" class="card-icon"><div class="card-title" style="color:${def.color}">${def.name}</div><div class="card-desc">${def.desc}</div>`;
        card.onclick = () => { creationData.classKey = key; showCreationStep('name'); randomizeName(); };
        grid.appendChild(card);
    }
}

function randomizeName() {
    document.getElementById('char-name-input').value = getRandomName(creationData.race);
}

function finalizeCreation() {
    const nameInput = document.getElementById('char-name-input').value;
    creationData.name = nameInput || getRandomName(creationData.race);
    document.getElementById('char-creation-screen').classList.add('hidden');
    startGame(creationData);
}

function closeCreation() {
    document.getElementById('char-creation-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
}

function openRoster() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('roster-screen').classList.remove('hidden');
    const grid = document.getElementById('roster-grid');
    grid.innerHTML = '';
    if (META.roster.length === 0) { grid.innerHTML = "<p>No active mercenaries available.</p>"; return; }
    META.roster.forEach((char, index) => {
        const def = CLASS_DEFS[char.type];
        const race = RACES[char.race];
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `<img src="${ASSETS[def.imgKey]?.src}" class="card-icon"><div class="card-title" style="color:${def.color}">${char.name}</div><div class="card-role">${race.name} ${def.name}</div><div class="card-desc">Kills: ${char.kills||0}<br>Earned: ${char.gp||0}g</div>`;
        card.onclick = () => { META.roster.splice(index, 1); saveGame(); document.getElementById('roster-screen').classList.add('hidden'); startGame(char); };
        grid.appendChild(card);
    });
}
function closeRoster() { document.getElementById('roster-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function renderCamp() {
    const grid = document.getElementById('camp-grid');
    grid.innerHTML = '';
    let currentCat = '';
    UPGRADES.forEach(u => {
        if (u.category !== currentCat) {
            const header = document.createElement('div');
            header.className = 'camp-section'; header.innerText = u.category;
            grid.appendChild(header); currentCat = u.category;
        }
        const isBought = META.upgrades[u.id];
        const btn = document.createElement('div');
        btn.className = `upgrade-btn ${isBought ? 'purchased' : ''}`;
        
        // Add Icon if exists
        const iconHtml = u.imgKey && ASSETS[u.imgKey] ? `<img src="${ASSETS[u.imgKey].src}" class="upgrade-btn-icon">` : '';
        
        btn.innerHTML = `
            ${iconHtml}
            <div style="flex-grow:1;">
                <span class="upgrade-name">${u.name}</span>
                <span class="upgrade-cost">${isBought ? 'OWNED' : u.cost + 'g'}</span>
            </div>
            <div class="upgrade-desc">${u.desc}</div>
        `;
        if (!isBought) btn.onclick = () => buyUpgrade(u.id, u.cost);
        grid.appendChild(btn);
    });
}

function buyUpgrade(id, cost) {
    if (META.gold >= cost) { 
        META.gold -= cost; 
        META.upgrades[id] = true; 
        saveGame(); 
        renderCamp(); 
        renderCampVisuals(); // Update visuals immediately
    }
}

function renderCampVisuals() {
    const container = document.getElementById('camp-visuals');
    if (!container) return;
    container.innerHTML = '';
    
    UPGRADES.forEach(u => {
        if (META.upgrades[u.id] && u.imgKey && ASSETS[u.imgKey]) {
            const img = document.createElement('img');
            img.src = ASSETS[u.imgKey].src;
            img.className = 'camp-building';
            img.style.left = u.x + '%';
            container.appendChild(img);
        }
    });
}

function openCamp() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('camp-screen').classList.remove('hidden'); renderCamp(); }
function closeCamp() { document.getElementById('camp-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

function openManual() {
    const container = document.getElementById('manual-content'); container.innerHTML = '';
    const raceHeader = document.createElement('div'); raceHeader.className = 'manual-section-header'; raceHeader.innerText = "Backgrounds (Races)"; container.appendChild(raceHeader);
    for (const key in RACES) {
        const r = RACES[key];
        container.innerHTML += `<div class="manual-card"><div class="manual-card-header"><div class="manual-title">${r.name}</div></div><div class="manual-desc" style="margin-bottom:10px;">${r.desc}</div><div class="manual-stats"><div class="manual-stat-row" style="color: #8b0000; text-align:center;">${r.statsText}</div></div></div>`;
    }
    const classHeader = document.createElement('div'); classHeader.className = 'manual-section-header'; classHeader.innerText = "Specialties (Classes)"; classHeader.style.marginTop = "30px"; container.appendChild(classHeader);
    for (const key in CLASS_DEFS) {
        const d = CLASS_DEFS[key];
        const as = (60 / d.cooldown).toFixed(1);
        container.innerHTML += `<div class="manual-card"><div class="manual-card-header"><img src="${ASSETS[d.imgKey]?.src}" class="manual-icon"><div><div class="manual-title">${d.name}</div><div class="manual-role">${d.role}</div></div></div><div class="manual-stats"><div class="manual-stat-row"><span>Damage:</span> <span style="color:#8b0000">${d.damage}</span></div><div class="manual-stat-row"><span>Range:</span> <span style="color:#00008b">${d.range}</span></div><div class="manual-stat-row"><span>Attack Speed:</span> <span style="color:#006400">${as}/sec</span></div></div><div class="manual-desc">${d.desc}</div></div>`;
    }
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('manual-screen').classList.remove('hidden');
}
function closeManual() { document.getElementById('manual-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden'); }

// ==========================================
// 7. GAME LOOP & LOGIC
// ==========================================

function initGame(charData) {
    player = {
        x: GAME.width / 2, y: GAME.height / 2, radius: 12, color: '#D4AF37', angle: 0,
        imgKey: CLASS_DEFS[charData.classKey || charData.type].imgKey
    };
    squad = []; enemies = []; pickups = []; projectiles = []; floatingTexts = [];
    currentRunStats = { kills: 0, gold: 0 };
    addSquadMate(charData.classKey || charData.type, charData.race || 'HUMAN', charData.name);
}

function startGame(charData) {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    GAME.state = 'PLAY'; GAME.hp = GAME.maxHp; GAME.score = 0; GAME.time = 0;
    GAME.level = 1; GAME.xp = 0; GAME.xpReq = CONFIG.XP_BASE_REQ;
    GAME.luck = 5; GAME.maxLuck = 20; GAME.luckBurnCount = 0; GAME.formation = 'WEDGE';
    
    if (META.upgrades['brothel']) GAME.maxLuck += 2;
    if (META.upgrades['kitchen']) { GAME.maxHp += 20; GAME.hp = GAME.maxHp; }
    if (META.upgrades['church']) { GAME.maxHp += 50; GAME.hp = GAME.maxHp; }
    
    initGame(charData);
    const race = RACES[charData.race || 'HUMAN'];
    if (race) {
        if (race.hp) { GAME.maxHp += race.hp; GAME.hp = GAME.maxHp; }
        if (race.luck) { GAME.maxLuck += race.luck; GAME.luck = Math.min(GAME.luck, GAME.maxLuck); }
        player.raceSpeedMult = race.moveSpeed || 1.0;
    } else { player.raceSpeedMult = 1.0; }
    animate();
}

function checkSquadSynergies() {
    GAME.canUseShieldWall = squad.some(m => m.type === 'SOLDIER' && m.level >= 3);
    const indicator = document.getElementById('tactic-name');
    if (!GAME.canUseShieldWall && GAME.formation === 'SHIELD') toggleFormation();
    document.getElementById('tutorial').innerHTML = `WASD: Move<br>SPACE: Toggle Formation (${GAME.canUseShieldWall ? 'READY' : 'LOCKED - Need Lvl 3 Soldier'})<br>Q: Burn Luck (Ultimate)`;
}

function toggleFormation() {
    if (!GAME.canUseShieldWall) { addFloatingText(player.x, player.y - 40, "NEED LVL 3 SOLDIER", "gray"); return; }
    GAME.formation = GAME.formation === 'WEDGE' ? 'SHIELD' : 'WEDGE';
    const indicator = document.getElementById('tactic-name');
    indicator.innerText = GAME.formation;
    indicator.style.color = GAME.formation === 'WEDGE' ? '#d4af37' : '#4169e1';
    addFloatingText(player.x, player.y - 30, GAME.formation, "#fff");
}

function burnLuck() {
    if (GAME.luck >= GAME.maxLuck * 0.5) { 
        enemies.forEach(e => takeEnemyDamage(e, 9999));
        ctx.fillStyle = "white"; ctx.fillRect(0,0,GAME.width, GAME.height);
        GAME.luck = 0; GAME.maxLuck = Math.max(5, GAME.maxLuck - 5); GAME.luckBurnCount++;
        addFloatingText(player.x, player.y - 50, "LUCK BURNED!", "red");
    } else { addFloatingText(player.x, player.y - 30, "NOT ENOUGH LUCK", "gray"); }
}

function addSquadMate(type, race = null, name = null) {
    if (squad.length >= CONFIG.MAX_TOTAL_SQUAD_SIZE) return;
    if (squad.length === 6 && META.gold >= CONFIG.SECOND_LEADER_COST) {
        META.gold -= CONFIG.SECOND_LEADER_COST; saveGame();
        addFloatingText(player.x, player.y, "-20 Gold", "gold");
    }
    if (!race) race = Object.keys(RACES)[Math.floor(Math.random() * 6)];
    if (!name) name = getRandomName(race);
    squad.push(new SquadMate(type, squad.length, race, name)); 
    checkSquadSynergies(); updateUI();
}

function takeEnemyDamage(enemy, dmg, knockback = false) {
    enemy.hp -= dmg;
    if (Math.random() > 0.5) addFloatingText(enemy.x, enemy.y, dmg, "#fff");
    if (knockback) {
        const angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
        enemy.x += Math.cos(angle) * 20; enemy.y += Math.sin(angle) * 20;
    }
    if (enemy.hp <= 0 && !enemy.markedForDeletion) {
        enemy.markedForDeletion = true;
        pickups.push(new XPOrb(enemy.x, enemy.y, enemy.xp));
        let dropChance = 0.1; 
        if (META.upgrades['merchant']) dropChance += 0.05;
        if (Math.random() < dropChance) pickups.push(new GoldOrb(enemy.x + 5, enemy.y + 5));
        GAME.luck = Math.min(GAME.luck + 1, GAME.maxLuck);
        GAME.score += 10; currentRunStats.kills++;
    }
}

function takePlayerDamage(amount) {
    let dmg = amount;
    if (GAME.formation === 'SHIELD') dmg = Math.ceil(dmg * 0.5); 
    if (META.upgrades['leather']) dmg = Math.max(1, dmg - 1);
    GAME.hp -= dmg;
    addFloatingText(player.x, player.y, `-${dmg}`, "red");
    if (GAME.hp <= 0) gameOver();
}

function gainXP(amount) {
    let finalAmt = amount;
    if (META.upgrades['cells']) finalAmt = Math.ceil(amount * 1.1);
    if (META.upgrades['grounds']) finalAmt = Math.ceil(amount * 1.2);
    GAME.xp += finalAmt;
    if (GAME.xp >= GAME.xpReq) levelUp();
}

function levelUp() {
    GAME.state = 'LEVELUP'; GAME.level++; GAME.xp = 0;
    GAME.xpReq = Math.floor(GAME.xpReq * CONFIG.XP_SCALING);
    if (META.upgrades['hospital']) GAME.hp = Math.min(GAME.hp + 20, GAME.maxHp);
    
    const grid = document.getElementById('upgrade-grid'); grid.innerHTML = '';
    
    // Create Columns
    const leftCol = document.createElement('div');
    leftCol.className = 'upgrade-column';
    const h1 = document.createElement('div'); h1.className = 'column-header'; h1.innerText = "Promote Squad";
    leftCol.appendChild(h1);
    
    const rightCol = document.createElement('div');
    rightCol.className = 'upgrade-column';
    const h2 = document.createElement('div'); h2.className = 'column-header'; h2.innerText = "Recruit New";
    rightCol.appendChild(h2);

    // Existing Squad -> Left Column
    squad.forEach((mate) => {
        const def = CLASS_DEFS[mate.type];
        const card = document.createElement('div'); card.className = 'upgrade-card'; card.style.borderColor = '#4169e1';
        let bonus = "Stats \u2191";
        if(mate.level===2) {
             const m = {"SOLDIER":"Shield Wall","CLERIC":"Auto Heal","MAGE":"Fireball","WITCH":"Fear","SCOUNDREL":"Traps","FOLK_HERO":"Magnet"};
             bonus = "Unlock: " + m[mate.type];
        }
        card.innerHTML = `<img src="${ASSETS[def.imgKey]?.src}" class="card-icon"><div class="card-title">UPGRADE</div><div class="card-role" style="color:${def.color}">${def.name} Lvl ${mate.level} \u2192 ${mate.level+1}</div><div class="card-desc" style="color:#aaf">${bonus}</div>`;
        card.onclick = () => { mate.upgrade(); closeLevelUp(); };
        leftCol.appendChild(card);
    });

    // New Recruits -> Right Column
    if (squad.length === 6) { // 2nd Leader Logic
        const choices = Object.keys(CLASS_DEFS).sort(() => 0.5 - Math.random()).slice(0, 3);
        choices.forEach(key => {
            const def = CLASS_DEFS[key];
            const rKey = Object.keys(RACES)[Math.floor(Math.random()*6)];
            const canAfford = META.gold >= CONFIG.SECOND_LEADER_COST;
            const card = document.createElement('div'); card.className = `upgrade-card ${!canAfford?'disabled':''}`; card.style.borderColor = canAfford?'#d4af37':'#444';
            card.innerHTML = `<img src="${ASSETS[def.imgKey]?.src}" class="card-icon"><div class="card-title">CAPTAIN</div><div class="card-role">${RACES[rKey].name} ${def.name}</div><div class="card-desc" style="color: gold">Cost: ${CONFIG.SECOND_LEADER_COST}g</div>`;
            if (canAfford) card.onclick = () => { addSquadMate(key, rKey); closeLevelUp(); };
            rightCol.appendChild(card);
        });
    } else if (squad.length < CONFIG.MAX_TOTAL_SQUAD_SIZE) {
        const choices = Object.keys(CLASS_DEFS).sort(() => 0.5 - Math.random()).slice(0, 3);
        choices.forEach(key => {
            const def = CLASS_DEFS[key];
            const rKey = Object.keys(RACES)[Math.floor(Math.random()*6)];
            const card = document.createElement('div'); card.className = 'upgrade-card'; card.style.borderColor = '#d4af37';
            card.innerHTML = `<img src="${ASSETS[def.imgKey]?.src}" class="card-icon"><div class="card-title">RECRUIT</div><div class="card-role">${RACES[rKey].name} ${def.name}</div>`;
            card.onclick = () => { addSquadMate(key, rKey); closeLevelUp(); };
            rightCol.appendChild(card);
        });
    }
    
    // Rations Fallback (Always available option on the right)
    const ration = document.createElement('div'); ration.className = 'upgrade-card'; ration.style.borderColor = '#00ff00';
    ration.innerHTML = `<div class="card-title">RATIONS</div><div class="card-desc">Heal 30% HP</div>`;
    ration.onclick = () => { GAME.hp = Math.min(GAME.maxHp, GAME.hp + (GAME.maxHp*0.3)); closeLevelUp(); };
    rightCol.appendChild(ration);
    
    grid.appendChild(leftCol);
    grid.appendChild(rightCol);
    
    document.getElementById('levelup-screen').classList.remove('hidden');
}

function closeLevelUp() { document.getElementById('levelup-screen').classList.add('hidden'); GAME.state = 'PLAY'; }

function gameOver() {
    GAME.state = 'GAMEOVER'; saveGame();
    document.getElementById('death-stats').innerText = `Survived: ${document.getElementById('timer').innerText} | Level: ${GAME.level} | Gold: ${META.gold}`;
    const rezBtn = document.getElementById('resurrect-btn');
    if (META.gold >= 10) { rezBtn.classList.remove('btn-disabled'); rezBtn.innerHTML = "RESURRECT LEADER (10g)"; }
    else { rezBtn.classList.add('btn-disabled'); rezBtn.innerHTML = "RESURRECT LEADER (Too Poor)"; }
    document.getElementById('gameover-screen').classList.remove('hidden');
}

function resurrectLeader() {
    if (META.gold >= 10 && player) {
        META.gold -= 10;
        const leader = squad[0];
        META.roster.push({ type: leader.type, race: leader.race, name: leader.name, kills: currentRunStats.kills, gp: currentRunStats.gold });
        saveGame(); location.reload();
    }
}

function update() {
    if (GAME.state !== 'PLAY') return;
    GAME.frames++;
    if (GAME.frames % 60 === 0) { GAME.time++; if (META.upgrades['housing'] && GAME.hp < GAME.maxHp) GAME.hp = Math.min(GAME.maxHp, GAME.hp + 0.5); }
    if (GAME.frames % CONFIG.ENEMY_SPAWN_RATE === 0) enemies.push(new Enemy());

    let moveSpeed = (GAME.formation === 'WEDGE' ? CONFIG.PLAYER_SPEED_WEDGE : CONFIG.PLAYER_SPEED_SHIELD) * (META.upgrades['stables'] ? 1.1 : 1.0) * (player.raceSpeedMult || 1.0);
    let dx = 0, dy = 0;
    if (keys.w) dy -= 1; if (keys.s) dy += 1; if (keys.a) dx -= 1; if (keys.d) dx += 1;
    if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx = (dx/len) * moveSpeed; dy = (dy/len) * moveSpeed;
        player.x += dx; player.y += dy; player.angle = Math.atan2(dy, dx);
    }
    player.x = Math.max(10, Math.min(GAME.width-10, player.x));
    player.y = Math.max(10, Math.min(GAME.height-10, player.y));

    squad.forEach(mate => mate.update(player.x, player.y, player.angle, GAME.formation));
    enemies.forEach(e => e.update()); enemies = enemies.filter(e => !e.markedForDeletion);
    projectiles.forEach(p => p.update()); projectiles = projectiles.filter(p => !p.markedForDeletion);
    pickups.forEach(p => p.update()); pickups = pickups.filter(p => !p.markedForDeletion);
    floatingTexts.forEach(t => { t.y -= 0.5; t.life--; }); floatingTexts = floatingTexts.filter(t => t.life > 0);

    if (GAME.time >= 20 * 60) { GAME.state = 'WIN'; saveGame(); document.getElementById('win-screen').classList.remove('hidden'); }
    updateUI();
}

function updateUI() {
    document.getElementById('hp-bar').style.width = `${Math.max(0, (GAME.hp/GAME.maxHp)*100)}%`;
    document.getElementById('xp-bar').style.width = `${Math.min(100, (GAME.xp/GAME.xpReq)*100)}%`;
    document.getElementById('luck-bar').style.width = `${Math.min(100, (GAME.luck/GAME.maxLuck)*100)}%`;
    document.getElementById('luck-text').innerText = `${GAME.luck} / ${GAME.maxLuck}`;
    const mins = Math.floor(GAME.time / 60).toString().padStart(2, '0');
    const secs = (GAME.time % 60).toString().padStart(2, '0');
    document.getElementById('timer').innerText = `${mins}:${secs}`;
    document.getElementById('squad-count').innerText = `${squad.length}/${CONFIG.MAX_TOTAL_SQUAD_SIZE}`;
    document.getElementById('level-display').innerText = GAME.level;
    document.getElementById('gold-hud').innerText = META.gold;
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);
    const bgImg = ASSETS['BACKGROUND'];
    if (bgImg && bgImg.complete) { ctx.fillStyle = ctx.createPattern(bgImg, 'repeat'); ctx.fillRect(0, 0, canvas.width, canvas.height); }
    pickups.forEach(p => p.draw());
    
    // Draw Leader
    const leaderImg = ASSETS[player.imgKey];
    if (leaderImg && leaderImg.complete) {
        const size = player.radius * 3.0;
        ctx.drawImage(leaderImg, player.x - size/2, player.y - size/2, size, size);
        ctx.beginPath(); ctx.arc(player.x, player.y, player.radius * 1.5, 0, Math.PI * 2);
        ctx.lineWidth = 2; ctx.strokeStyle = "#D4AF37"; ctx.stroke();
    }
    squad.forEach(mate => mate.draw());
    enemies.forEach(e => e.draw());
    projectiles.forEach(p => p.draw());
    floatingTexts.forEach(t => { ctx.fillStyle = t.color; ctx.font = "bold 16px Courier New"; ctx.fillText(t.text, t.x, t.y); });
}

function animate() {
    update(); draw();
    if (GAME.state === 'PLAY' || GAME.state === 'LEVELUP') requestAnimationFrame(animate);
}

// ==========================================
// 8. INITIALIZATION
// ==========================================

window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    GAME.width = canvas.width;
    GAME.height = canvas.height;
    
    loadAssets();
    loadGame();
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        GAME.width = canvas.width; GAME.height = canvas.height;
    });

    window.addEventListener('keydown', e => {
        if(e.key === ' ' || e.key === 'Spacebar') { if(GAME.state === 'PLAY' && !keys.space) toggleFormation(); keys.space = true; }
        if(e.key.toLowerCase() === 'q') { if(GAME.state === 'PLAY' && !keys.q) burnLuck(); keys.q = true; }
        if(['w','a','s','d','ArrowUp','ArrowLeft','ArrowDown','ArrowRight'].includes(e.key)) {
            keys[e.key.toLowerCase().replace('arrowup','w').replace('arrowleft','a').replace('arrowdown','s').replace('arrowright','d')] = true;
        }
    });

    window.addEventListener('keyup', e => {
        if(e.key === ' ' || e.key === 'Spacebar') keys.space = false;
        if(e.key.toLowerCase() === 'q') keys.q = false;
        if(['w','a','s','d','ArrowUp','ArrowLeft','ArrowDown','ArrowRight'].includes(e.key)) {
            keys[e.key.toLowerCase().replace('arrowup','w').replace('arrowleft','a').replace('arrowdown','s').replace('arrowright','d')] = false;
        }
    });
};
</script>
</body>
</html>
